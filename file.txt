admin:
  address:
    socket_address:
      address: 127.0.0.1
      port_value: 15444

static_resources:
  listeners:
    - name: listener_00
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 9090
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: sample_prefix
                http_filters:
                  - name: envoy.filters.http.jwt_authn
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                      providers:
                        provider_00:
                          issuer: "<issuer>"
                          remote_jwks:
                            http_uri:
                              uri: "http://proxy_cluster"  # Points to the proxy cluster for JWKS requests
                              cluster: proxy_cluster
                              timeout: 1s
                            cache_duration:
                              seconds: 300
                      rules:
                        - match:
                            prefix: "/"
                          requires:
                            provider_name: provider_00
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
                route_config:
                  name: route_00
                  virtual_hosts:
                    - name: service_00
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            host_rewrite_literal: localhost
                            cluster: cluster_00  # Routes to the Flask app cluster after JWT validation

  clusters:
    - name: cluster_00
      type: LOGICAL_DNS
      dns_lookup_family: V4_ONLY
      load_assignment:
        cluster_name: cluster_00
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: localhost  # Assuming Flask app is running on the same host
                      port_value: 8888  # Port where your Flask app is running

    - name: proxy_cluster  # Proxy cluster for JWKS requests
      type: STRICT_DNS
      connect_timeout: 0.25s
      dns_lookup_family: V4_ONLY
      load_assignment:
        cluster_name: proxy_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: <proxy_server_address>  # Your proxy server address
                      port_value: <proxy_server_port>  # Your proxy server port
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: login.microsoftonline.com




To effectively use a TCP proxy for HTTP(S) traffic in a scenario like fetching JWKS, you would typically need to ensure the following:

Your Proxy Server Configuration: Your firm's proxy server should be configured to handle outbound TCP connections from Envoy and route them to the correct HTTP(S) destination based on the destination IP address, port, or other identifiable information in the TCP stream.

DNS Resolution: Ensure that DNS resolution for the JWKS endpoint (login.microsoftonline.com in your case) is handled in a way that directs Envoy to route the traffic through the TCP proxy. This might involve DNS overrides or specific network routing rules.

Encryption and Security: If the JWKS endpoint uses HTTPS (which is typical for secure JWKS fetching), your TCP proxy setup needs to handle TLS encryption/decryption appropriately, either by terminating TLS at the proxy or by using a tunneling method that preserves end-to-end encryption.

Given these considerations, using a TCP proxy for routing HTTP(S) JWKS requests is less straightforward than managing HTTP(S) traffic directly, due to the additional complexity of correctly handling HTTP(S) requests at the TCP level and ensuring secure, accurate routing of requests to their intended destination.


admin:
  address:
    socket_address:
      address: 127.0.0.1
      port_value: 15444

static_resources:
  listeners:
    - name: listener_00
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 9090
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: sample_prefix
                http_filters:
                  - name: envoy.filters.http.jwt_authn
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                      providers:
                        provider_00:
                          issuer: "<issuer>"
                          # Assuming JWKS is fetched through an application logic or external means
                          local_jwks:
                            inline_string: "{\"keys\":[...]}"

                      rules:
                        - match:
                            prefix: "/"
                          requires:
                            provider_name: provider_00
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
                route_config:
                  name: route_00
                  virtual_hosts:
                    - name: service_00
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            host_rewrite_literal: localhost
                            cluster: cluster_00

    - name: tcp_listener  # Listener for routing TCP traffic through proxy
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 12345  # Arbitrary port, adjust as needed
      filter_chains:
        - filters:
            - name: envoy.filters.network.tcp_proxy
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
                stat_prefix: tcp_stats
                cluster: tcp_proxy_cluster

  clusters:
    - name: cluster_00
      type: LOGICAL_DNS
      dns_lookup_family: V4_ONLY
      load_assignment:
        cluster_name: cluster_00
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: localhost
                      port_value: 8888

    - name: tcp_proxy_cluster  # TCP Proxy cluster configuration
      type: STRICT_DNS
      connect_timeout: 0.25s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: tcp_proxy_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: <proxy_server_address>
                      port_value: <proxy_server_port>

To integrate a TCP proxy setup into your existing Envoy configuration for routing JWT verification requests to Microsoft through your firm's proxy, we'll assume that your main goal is to ensure all traffic destined for Microsoft's JWKS endpoint is intercepted and routed through a TCP proxy. This approach is somewhat unconventional for HTTP-based JWKS fetching and might not directly address the high-level operation (e.g., HTTP headers, method, path) but will serve as a basic demonstration of how to route traffic through a TCP proxy.

Given this setup, you'll need to ensure that the actual routing to Microsoft's JWKS endpoint through the TCP proxy is handled by either the proxy itself or through DNS/network configurations outside of Envoy. Here's how you can modify your configuration:

```yaml
admin:
  address:
    socket_address:
      address: 127.0.0.1
      port_value: 15444

static_resources:
  listeners:
    - name: listener_00
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 9090
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: sample_prefix
                http_filters:
                  - name: envoy.filters.http.jwt_authn
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                      providers:
                        provider_00:
                          issuer: "<issuer>"
                          # Assuming JWKS is fetched through an application logic or external means
                          local_jwks:
                            inline_string: "{\"keys\":[...]}"

                      rules:
                        - match:
                            prefix: "/"
                          requires:
                            provider_name: provider_00
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
                route_config:
                  name: route_00
                  virtual_hosts:
                    - name: service_00
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            host_rewrite_literal: localhost
                            cluster: cluster_00

    - name: tcp_listener  # Listener for routing TCP traffic through proxy
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 12345  # Arbitrary port, adjust as needed
      filter_chains:
        - filters:
            - name: envoy.filters.network.tcp_proxy
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
                stat_prefix: tcp_stats
                cluster: tcp_proxy_cluster

  clusters:
    - name: cluster_00
      type: LOGICAL_DNS
      dns_lookup_family: V4_ONLY
      load_assignment:
        cluster_name: cluster_00
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: localhost
                      port_value: 8888

    - name: tcp_proxy_cluster  # TCP Proxy cluster configuration
      type: STRICT_DNS
      connect_timeout: 0.25s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: tcp_proxy_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: <proxy_server_address>
                      port_value: <proxy_server_port>
def normalize_parameters(parameters):
    # If parameters is None or empty, return an empty list
    if not parameters:
        return []
    # If parameters is already a list, return as-is
    elif isinstance(parameters, list):
        return parameters
    # If parameters is a single dictionary/object, wrap it in a list
    elif isinstance(parameters, dict):
        # Check if it's a singular object or key-value pairs
        # Assuming key-value pairs means a flat dictionary, not nested
        if all(not isinstance(value, dict) for value in parameters.values()):
            # Convert key-value pairs into a list containing one object
            return [parameters]
        else:
            # Handle nested objects differently if necessary
            return [parameters]
    else:
        # Placeholder for handling other unexpected formats (e.g., string representations)
        return []
