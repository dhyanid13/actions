admin:
  address:
    socket_address:
      address: 127.0.0.1
      port_value: 15444

static_resources:
  listeners:
    - name: listener_00
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 9090
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: sample_prefix
                http_filters:
                  - name: envoy.filters.http.jwt_authn
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                      providers:
                        provider_00:
                          issuer: "<issuer>"
                          remote_jwks:
                            http_uri:
                              uri: "http://proxy_cluster"  # Points to the proxy cluster for JWKS requests
                              cluster: proxy_cluster
                              timeout: 1s
                            cache_duration:
                              seconds: 300
                      rules:
                        - match:
                            prefix: "/"
                          requires:
                            provider_name: provider_00
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
                route_config:
                  name: route_00
                  virtual_hosts:
                    - name: service_00
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            host_rewrite_literal: localhost
                            cluster: cluster_00  # Routes to the Flask app cluster after JWT validation

  clusters:
    - name: cluster_00
      type: LOGICAL_DNS
      dns_lookup_family: V4_ONLY
      load_assignment:
        cluster_name: cluster_00
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: localhost  # Assuming Flask app is running on the same host
                      port_value: 8888  # Port where your Flask app is running

    - name: proxy_cluster  # Proxy cluster for JWKS requests
      type: STRICT_DNS
      connect_timeout: 0.25s
      dns_lookup_family: V4_ONLY
      load_assignment:
        cluster_name: proxy_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: <proxy_server_address>  # Your proxy server address
                      port_value: <proxy_server_port>  # Your proxy server port
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: login.microsoftonline.com




To effectively use a TCP proxy for HTTP(S) traffic in a scenario like fetching JWKS, you would typically need to ensure the following:

Your Proxy Server Configuration: Your firm's proxy server should be configured to handle outbound TCP connections from Envoy and route them to the correct HTTP(S) destination based on the destination IP address, port, or other identifiable information in the TCP stream.

DNS Resolution: Ensure that DNS resolution for the JWKS endpoint (login.microsoftonline.com in your case) is handled in a way that directs Envoy to route the traffic through the TCP proxy. This might involve DNS overrides or specific network routing rules.

Encryption and Security: If the JWKS endpoint uses HTTPS (which is typical for secure JWKS fetching), your TCP proxy setup needs to handle TLS encryption/decryption appropriately, either by terminating TLS at the proxy or by using a tunneling method that preserves end-to-end encryption.

Given these considerations, using a TCP proxy for routing HTTP(S) JWKS requests is less straightforward than managing HTTP(S) traffic directly, due to the additional complexity of correctly handling HTTP(S) requests at the TCP level and ensuring secure, accurate routing of requests to their intended destination.


admin:
  address:
    socket_address:
      address: 127.0.0.1
      port_value: 15444

static_resources:
  listeners:
    - name: listener_00
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 9090
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: sample_prefix
                http_filters:
                  - name: envoy.filters.http.jwt_authn
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                      providers:
                        provider_00:
                          issuer: "<issuer>"
                          # Assuming JWKS is fetched through an application logic or external means
                          local_jwks:
                            inline_string: "{\"keys\":[...]}"

                      rules:
                        - match:
                            prefix: "/"
                          requires:
                            provider_name: provider_00
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
                route_config:
                  name: route_00
                  virtual_hosts:
                    - name: service_00
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            host_rewrite_literal: localhost
                            cluster: cluster_00

    - name: tcp_listener  # Listener for routing TCP traffic through proxy
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 12345  # Arbitrary port, adjust as needed
      filter_chains:
        - filters:
            - name: envoy.filters.network.tcp_proxy
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
                stat_prefix: tcp_stats
                cluster: tcp_proxy_cluster

  clusters:
    - name: cluster_00
      type: LOGICAL_DNS
      dns_lookup_family: V4_ONLY
      load_assignment:
        cluster_name: cluster_00
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: localhost
                      port_value: 8888

    - name: tcp_proxy_cluster  # TCP Proxy cluster configuration
      type: STRICT_DNS
      connect_timeout: 0.25s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: tcp_proxy_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: <proxy_server_address>
                      port_value: <proxy_server_port>

To integrate a TCP proxy setup into your existing Envoy configuration for routing JWT verification requests to Microsoft through your firm's proxy, we'll assume that your main goal is to ensure all traffic destined for Microsoft's JWKS endpoint is intercepted and routed through a TCP proxy. This approach is somewhat unconventional for HTTP-based JWKS fetching and might not directly address the high-level operation (e.g., HTTP headers, method, path) but will serve as a basic demonstration of how to route traffic through a TCP proxy.

Given this setup, you'll need to ensure that the actual routing to Microsoft's JWKS endpoint through the TCP proxy is handled by either the proxy itself or through DNS/network configurations outside of Envoy. Here's how you can modify your configuration:

```yaml
admin:
  address:
    socket_address:
      address: 127.0.0.1
      port_value: 15444

static_resources:
  listeners:
    - name: listener_00
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 9090
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: sample_prefix
                http_filters:
                  - name: envoy.filters.http.jwt_authn
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                      providers:
                        provider_00:
                          issuer: "<issuer>"
                          # Assuming JWKS is fetched through an application logic or external means
                          local_jwks:
                            inline_string: "{\"keys\":[...]}"

                      rules:
                        - match:
                            prefix: "/"
                          requires:
                            provider_name: provider_00
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
                route_config:
                  name: route_00
                  virtual_hosts:
                    - name: service_00
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            host_rewrite_literal: localhost
                            cluster: cluster_00

    - name: tcp_listener  # Listener for routing TCP traffic through proxy
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 12345  # Arbitrary port, adjust as needed
      filter_chains:
        - filters:
            - name: envoy.filters.network.tcp_proxy
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
                stat_prefix: tcp_stats
                cluster: tcp_proxy_cluster

  clusters:
    - name: cluster_00
      type: LOGICAL_DNS
      dns_lookup_family: V4_ONLY
      load_assignment:
        cluster_name: cluster_00
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: localhost
                      port_value: 8888

    - name: tcp_proxy_cluster  # TCP Proxy cluster configuration
      type: STRICT_DNS
      connect_timeout: 0.25s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: tcp_proxy_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: <proxy_server_address>
                      port_value: <proxy_server_port>
```

**Important Notes:**

1. **TCP Listener and Cluster**: I've added a `tcp_listener` and `tcp_proxy_cluster` to route TCP traffic through your specified proxy. This is separate from the HTTP listener used for your Flask application and JWT handling. This TCP proxy setup is intended to demonstrate how you might configure TCP-level routing, but keep in mind that direct JWKS fetching via this method isn't straightforward without additional network or proxy configurations.

2. **JWT Configuration**: The example assumes JWKS is managed externally (e.g., fetched and updated by application logic or other means) and then configured inline for simplicity in this example. This approach bypasses the need to fetch JWKS via Envoy, given the complexities of routing HTTP JWKS fetch requests through a TCP proxy.

3. **Routing JWKS Requests**: To effectively use this TCP proxy for JWKS fetching, you'd need to ensure external configurations (DNS overrides, proxy configurations) are set up to intercept and route JWKS requests from Envoy through the TCP proxy to Microsoft. This setup depends heavily on your network and proxy capabilities and configurations.

This integrated configuration provides a basic framework for incorporating TCP proxying into your Envoy setup. However, due to the complexity of correctly routing HTTP(S) requests (like JWKS fetching) through a TCP proxy, this solution may require additional network and proxy configuration outside of Envoy to work as intended

