pipeline {
    agent any
    stages {
        stage('Stage 1') {
            steps {
                script {
                    // Generate random text
                    def randomText = "Random text: " + UUID.randomUUID().toString()
                    // Create a file in the workspace and write the random text
                    writeFile file: 'shared_file.txt', text: randomText
                    // Echo the initial text for visibility
                    echo "Initial Text: ${randomText}"
                }
            }
        }
        stage('Stage 2') {
            steps {
                script {
                    lock(resource: 'shared-file-lock') {
                        // Read the content of the shared text file from the workspace
                        def textToUpdate = readFile 'shared_file.txt'
                        // Modify the text by adding the build number
                        textToUpdate += "\nUpdated by Stage 2 - Build Number: ${env.BUILD_NUMBER}"
                        // Write the modified text back to the shared text file in the workspace
                        writeFile file: 'shared_file.txt', text: textToUpdate
                        // Echo the text after modification
                        echo "Text After Edit: ${textToUpdate}"
                    }
                }
            }
        }
    }
    post {
        always {
            milestone()
        }
    }
}

import os
import subprocess
from pathlib import Path
import argparse

class CloudDeploy:
    def __init__(self):
        self.setup_env()

    @property
    def user(self):
        return os.getenv('USER', 'default_user')

    @property
    def hostname(self):
        return os.getenv('HOSTNAME', 'localhost')

    @property
    def cinitccname(self):
        return os.getenv('CINITCCNAME', f"/var/spool/certs/{self.user}")

    @cinitccname.setter
    def cinitccname(self, value):
        os.environ['CINITCCNAME'] = value

    @property
    def docker_host(self):
        return os.getenv('DOCKER_HOST', f"tcp://{self.hostname}:2376")

    @property
    def docker_tls_verify(self):
        return os.getenv('DOCKER_TLS_VERIFY', '1')

    @property
    def docker_cert_path(self):
        return os.getenv('DOCKER_CERT_PATH', f"{self.cinitccname}")

    @property
    def ticket_path(self):
        return Path(f"/var/spool/tickets/{self.user}")

    @property
    def workspace(self):
        workspace_dir = "/var/tmp/k8s-cloud-deploy"
        if not os.path.exists(workspace_dir):
            os.makedirs(workspace_dir)
        os.environ['WORKSPACE'] = workspace_dir
        return workspace_dir

    @property
    def cloud_deploy_version(self):
        return os.getenv('CLOUD_DEPLOY_VERSION', '2024.05.16-89')

    @property
    def mongo_connection_string(self):
        default_mongo_string = (
            f"mongodb://ivapp1388351.devin1.ms.com:27000,"
            f"ivapp1388352.devin1.ms.com:27000,ivapp1388353.devin1.ms.com:27000/"
            f"d_cloud-deploy?replicaSet=rs&tls=true&tlsCertificateKeyFile="
            f"{self.cinitccname}/combined-cert-key.pem&tlsCAFile=/etc/ssl/certs/ca-bundle.crt&authMechanism=MONGODB-X509"
        )
        return os.getenv('CLOUD_DEPLOY_CONNECTION_STRING', default_mongo_string)

    def setup_env(self):
        if self.ticket_path.is_file() and self.ticket_path.stat().st_size > 0:
            self.cinitccname = f"/var/spool/certs/{self.user}"
        else:
            if self.user:
                self.cinitccname = f"/var/spool/certs/{self.user}"
            else:
                print("Error: Unable to determine the current user.")
                exit(1)

        # Ensure CINITCCNAME directory exists
        cinitccname_path = Path(self.cinitccname)
        if not cinitccname_path.is_dir():
            print(f"Error: {self.cinitccname} must exist to get client certs.")
            exit(1)

        os.environ['DOCKER_TLS_VERIFY'] = self.docker_tls_verify
        os.environ['DOCKER_HOST'] = self.docker_host
        os.environ['DOCKER_CERT_PATH'] = self.cinitccname

    def run_docker_command(self, cmd):
        try:
            subprocess.run(cmd, shell=True, check=True)
        except subprocess.CalledProcessError as e:
            if "error during connect" in e.stderr:
                print("Error: Could not connect to Docker daemon. Please ensure Docker is running and accessible.")
            else:
                print(f"Error executing command: {e}")

    def status(self, container_name):
        cmd = f"docker inspect --format '{{{{.State.Running}}}}' {container_name}"
        status_result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        if status_result.stdout.strip() == 'true':
            print(f"Container {container_name} is running.")
            return True
        else:
            print(f"Container {container_name} is stopped.")
            return False

    def start(self, container_name='clouddeploy_container', worker_concurrency='2', label='k8s', mongo_connection_string=None):
        if self.status(container_name):
            print(f"Container {container_name} is already running.")
            return
        cmd = (
            f"docker run -d --name {container_name} "
            f"--cap-drop=NET_BIND_SERVICE "
            f"--cap-drop=SETGID "
            f"--cap-drop=SETUID "
            f"-e CINITCCNAME={self.cinitccname} "
            f"-e CLOUD_DEPLOY_K8S_BASELINE_IMAGE=cloud/k8s-baseline "
            f"-e CLOUD_DEPLOY_CONNECTION_STRING='{mongo_connection_string or self.mongo_connection_string}' "
            f"-e CLOUD_DEPLOY_SSL_CLIENT_CERT_FILE={self.cinitccname}/cert.pem "
            f"-e CLOUD_DEPLOY_SSL_CLIENT_CERT_KEY_FILE={self.cinitccname}/combined-cert-key.pem "
            f"-e CLOUD_DEPLOY_SSL_CLIENT_KEY_FILE={self.cinitccname}/key.pem "
            f"-e CLOUD_DEPLOY_K8S_WORKSPACE_DIR={self.workspace} "
            f"-e 'CLOUD_DEPLOY_WORKER_LABELS=[\"{label}\"]' "
            f"-e USER={self.user} "
            f"-e CLOUD_DEPLOY_WORKER_CONCURRENCY={worker_concurrency} "
            f"--network=host "
            f"--security-opt=no-new-privileges "
            f"-u {os.getuid()}:{os.getgid()} "
            f"-v {self.cinitccname}:{self.cinitccname}:ro "
            f"-v {self.workspace}:{self.workspace}:rw "
            f"-v /etc/nsswitch.conf:/etc/nsswitch.conf:ro "
            f"-v /var/db:/var/db:ro "
            f"msde/cloud-deploy:{self.cloud_deploy_version} "
            f"bin/run-worker.sh"
        )
        print("DEBUG DEBUG DEBUG DEBUG DEBUG DEBUG")
        print(cmd)
        self.run_docker_command(cmd)

    def stop(self, container_name='clouddeploy_container'):
        if not self.status(container_name):
            print(f"Container {container_name} is already stopped.")
            return
        self.run_docker_command(f"docker stop {container_name}")
        print(f"Container {container_name} is stopped.")

    def restart(self, container_name='clouddeploy_container', worker_concurrency='2', label='k8s', mongo_connection_string=None):
        if not self.status(container_name):
            print(f"Container {container_name} is stopped. Starting it...")
            self.start(container_name, worker_concurrency, label, mongo_connection_string)
        else:
            self.run_docker_command(f"docker restart {container_name}")
            print(f"Container {container_name} is restarted.")

def main():
    parser = argparse.ArgumentParser(description="Manage Cloud Deploy Docker Container")
    parser.add_argument('action', choices=['start', 'stop', 'restart'], help="Action to perform")
    parser.add_argument('--container-name', default='clouddeploy_container', help="Name of the Docker container")
    parser.add_argument('--worker-concurrency', default='2', help="Number of worker concurrency")
    parser.add_argument('--label', default='k8s', help="Cloud-deploy worker label")
    parser.add_argument('--mongo-connection-string', help="MongoDB connection string")

    args = parser.parse_args()

    cloud_deploy = CloudDeploy()

    if args.action == "start":
        cloud_deploy.start(args.container_name, args.worker_concurrency, args.label, args.mongo_connection_string)
    elif args.action == "stop":
        cloud_deploy.stop(args.container_name)
    elif args.action == "restart":
        cloud_deploy.restart(args.container_name, args.worker_concurrency, args.label, args.mongo_connection_string)

if __name__ == "__main__":
    main()
